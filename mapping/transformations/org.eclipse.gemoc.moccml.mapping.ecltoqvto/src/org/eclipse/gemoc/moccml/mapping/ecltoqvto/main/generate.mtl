[comment encoding = UTF-8 /]
[comment]/*******************************************************************************
 * Copyright (c) 2017 INRIA and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     I3S Kairos - initial API and implementation
 *******************************************************************************/[/comment]

[module generate(
http://www.eclipse.org/emf/2002/Ecore,
http://org.eclipse.gemoc.moccml.mapping,
http://www.eclipse.org/ocl/2015/CompleteOCLCS,
http://www.eclipse.org/ocl/2015/Pivot,
http://www.eclipse.org/ocl/2015/BaseCS,
http://www.eclipse.org/ocl/2015/EssentialOCLCS,
http://fr.inria.aoste.timemodel.ccslmodel.clockexpressionandrelation
)]


[template public eclToQvto(aMoCCMLMappingDoc : MoCCMLMappingDocument, resFileNames : String, rootElementName:String)]
[comment @main/] 
[let resultName : String = resFileNames ]
[file (resultName, false, 'UTF-8')]
import org.eclipse.gemoc.moccml_mapping.EclQVToHelper;
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
[for (p: PackageDeclarationCS | aMoCCMLMappingDoc.ownedPackages)]
	modeltype inMM[i/] uses '[p.referredPackage.URI/]';
[/for]

modeltype QVT 		uses 'http://www.eclipse.org/QVT/1.0.0/Operational';
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';
modeltype FeedBack 	uses 'http://timesquare.inria.fr/feedback';
modeltype Priority  uses 'http://fr.inria.aoste.timesquare.ccslkernel.solver.priorities';

transformation do[aMoCCMLMappingDoc.ownedImports->first().referredNamespace.toString().replaceAll('\\.', '_').replaceAll(':', '_').replaceAll('/', '_')/]_To_CCSL(in inM : inMM[getpackageIndex(aMoCCMLMappingDoc, rootElementName)/], out ccsl : TimeModel, out feedback : FeedBack, out priority: Priority);

property thePrioritySpec		:Priority::PrioritySpecification = null;
property theFeedBackSpec		:FeedBack::ActionModel = null;
property seqOfMSE :	Sequence(FeedBack::ModelSpecificEvent)    = Sequence{};
property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;
property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;
property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};
property allVarDefs : Sequence(String) = Sequence{}; 

query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	[for (im : ImportStatement | aMoCCMLMappingDoc.imports)]
	seqOfRelationDeclaration		+= getLibObjects("[im.importURI/]")['['/]TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration[']'/];
	seqOfAbstractEntity				+= getLibObjects("[im.importURI/]")['['/]TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity[']'/];
	seqOfExpressionDeclaration		+= getLibObjects("[im.importURI/]")['['/]TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration[']'/];
	kernelTypes 					+= getLibObjects("[im.importURI/]")['['/]TimeModel::BasicType::Type[']'/];
	[/for]

	Kernel_Integer 					:= kernelTypes['['/]name='int'[']'/]->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes['['/]name='clock'[']'/]->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()['['/]inMM[getpackageIndex(aMoCCMLMappingDoc, rootElementName)/]::[rootElementName/][']'/]->asSequence()->first()-> map [aMoCCMLMappingDoc.ownedPackages->asSequence()->first().pivot.oclAsType(NamedElement).name/]2CCSL();
	inM.rootObjects()['['/]inMM[getpackageIndex(aMoCCMLMappingDoc, rootElementName)/]::[rootElementName/][']'/]->asSequence()->first()-> map [aMoCCMLMappingDoc.ownedPackages->asSequence()->first().pivot.oclAsType(NamedElement).name/]2FeedBack();
	inM.rootObjects()['['/]inMM[getpackageIndex(aMoCCMLMappingDoc, rootElementName)/]::[rootElementName/][']'/]->asSequence()->first()-> map [aMoCCMLMappingDoc.ownedPackages->asSequence()->first().pivot.oclAsType(NamedElement).name/]2Priority();
}

			
	mapping inMM[getpackageIndex(aMoCCMLMappingDoc, rootElementName)/]::[rootElementName/]::[aMoCCMLMappingDoc.ownedPackages->asSequence()->first().pivot.oclAsType(NamedElement).name/]2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := getNameOrUID(self.oclAsType(EObject));
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;
		
		var anEmptyBlock :=object TimeModel::CCSLModel::Block{
	    	name := "emptyBlock";
	    };
	    subBlock += anEmptyBlock;
		
	[for (im : ImportStatement | aMoCCMLMappingDoc.imports)]
		imports+= object TimeModel::ImportStatement{
			importURI := '[im.importURI/]';
			alias := '[prettyPrintAlias(im.importURI.toString())/]';
			
		}; 
	[/for]
	
	[for (im: ImportCS | aMoCCMLMappingDoc.ownedImports)]
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};
	[/for]

	[comment]	create call for clock and constraint creations[/comment]
	[for (itsContext : ContextDeclCS | aMoCCMLMappingDoc.ownedPackages.ownedContexts)]
		

		[for (constraint : DefCS | itsContext.eAllContents(DefCS))]
			[if (constraint.ownedType <> null and constraint.ownedType.oclIsTypeOf(EventType))]
		////[ '[' /] [itsContext.pivot.oclAsType(NamedElement).name/] [ ']' /]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), [itsContext.pivot.oclAsType(NamedElement).name/].oclAsType(EClass)).oclAsType([itsContext.pivot.oclAsType(NamedElement).name/])->map [constraint.pivot.oclAsType(NamedElement).name/]2Clock();
			[/if]
			[if (constraint.ownedType <> null and constraint.ownedType.oclIsKindOf(PrimitiveTypeRefCS) and constraint.ownedType.oclAsType(PrimitiveTypeRefCS).name = 'Integer')]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), [itsContext.pivot.oclAsType(NamedElement).name/].oclAsType(EClass)).oclAsType([itsContext.pivot.oclAsType(NamedElement).name/])->map [constraint.pivot.oclAsType(NamedElement).name/]2Integer();
			[/if]
		[/for]
		


		[for (constraint : ConstraintCS | itsContext.eAllContents(ConstraintCS))]
			[for (expr : ExpCS | constraint.ownedSpecification.eAllContents(ExpCS))]	
				[if (expr.oclIsKindOf(MoCCMLRelation))]
		[comment]check if the relation is included in a navigatingExpression to change the call to the map		[/comment]
		
		[if not expr.eContainer(NavigatingArgCS).oclIsUndefined() ]

		[let navStringWithoutRelation : String = expr.eContainer(InfixExpCS).prettyPrintButRelation()]
		[let navStringWithoutRelationNorSelf : String = if(navStringWithoutRelation.contains('self.')) then navStringWithoutRelation.substring(6) else navStringWithoutRelation endif]
		[let correctString : String = navStringWithoutRelationNorSelf.substitute('StringToReplaceWithTheMapping', 'not ( a.map '+itsContext.pivot.oclAsType(NamedElement).name+expr.pivot.oclAsType(NamedElement).name+i+'2'+constraint.name)]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), [itsContext.pivot.oclAsType(NamedElement).name/].oclAsType(EClass))
				->forAll(a | a.[correctString/]);
		[/let]
		[/let]
		[/let]
		[else]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), [itsContext.pivot.oclAsType(NamedElement).name/].oclAsType(EClass)).oclAsType([itsContext.pivot.oclAsType(NamedElement).name/])->map [expr.ancestors(ConstraintCS)->first().name+i/]2[constraint.name/]();
		[/if]
		
				[/if]
			[/for]
		[/for]
	[/for] 
	}





//create the expressions...
	[for (expr : MoCCMLExpression | aMoCCMLMappingDoc.eAllContents(MoCCMLExpression))]

	[if expr.oclAsType(MoCCMLExpression).parameters->size() = 1 and expr.oclAsType(MoCCMLExpression).parameters->at(1).isACollection()] 
[comment]not expr.oclAsType(MoCCMLExpression).parameters->at(1).oclIsKindOf(NameExpCS)][/comment]
	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM[expr.getinMMindex()/]::[expr.getClassifierContext()/]::intermediate_[expr.parent.oclAsType(LetVariableCS).name/]2Expression(an1 : [expr.oclAsType(MoCCMLExpression).parameters->at(1).getTypeOfSet()/], an2 : [expr.oclAsType(MoCCMLExpression).parameters->at(1).getTypeOfSet()/], nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_[expr.parent.oclAsType(LetVariableCS).name/]'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "[expr.type.name/]")->first();
		//from defs
		[expr.createVarFromDefs()/]
		//from lets
		[expr.createVarFromLets()/]

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements['['/]name = getNameOrUID(an1.oclAsType(EObject))+'_[expr.oclAsType(MoCCMLExpression).parameters->at(1).prettyPrintOnlyLast()/]'[']'/]->first();
					[if (expr.oclAsType(MoCCMLExpression).type.oclIsKindOf(KernelExpressionDeclaration))]
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration['['/]name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::[expr.oclAsType(MoCCMLExpression).type.eClass().name/]).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					[else]
					_abstract := seqOfAbstractEntity['['/]name = '[expr.oclAsType(MoCCMLExpression).type.oclAsType(ExpressionDeclaration).parameters->at(1).name/]' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first();
					[/if]
				};
				[if (expr.oclAsType(MoCCMLExpression).type.oclIsKindOf(KernelExpressionDeclaration) or expr.oclAsType(MoCCMLExpression).type.oclAsType(ExpressionDeclaration).parameters->size() > 1) ]
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements['['/]name = getNameOrUID(an2.oclAsType(EObject))+'_[expr.oclAsType(MoCCMLExpression).parameters->at(1).prettyPrintOnlyLast()/]'[']'/]->first();
					[if (expr.oclAsType(MoCCMLExpression).type.oclIsKindOf(KernelExpressionDeclaration))]
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration['['/]name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::[expr.oclAsType(MoCCMLExpression).type.eClass().name/]).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					[else]
					_abstract := seqOfAbstractEntity['['/]name = '[expr.oclAsType(MoCCMLExpression).type.oclAsType(ExpressionDeclaration).parameters->at(1).name/]' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first();
					[/if]	
				};
				[/if]
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM[expr.getinMMindex()/]::[expr.getClassifierContext()/]::intermediate_[expr.parent.oclAsType(LetVariableCS).name/]2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : [expr.oclAsType(MoCCMLExpression).parameters->at(1).getTypeOfSet()/], nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_[expr.parent.oclAsType(LetVariableCS).name/]'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "[expr.type.name/]")->first();
		//from defs
		[expr.createVarFromDefs()/]
		//from lets
		[expr.createVarFromLets()/]
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions['['/]name = expr.name[']'/]->first();
					[if (expr.oclAsType(MoCCMLExpression).type.oclIsKindOf(KernelExpressionDeclaration))]
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration['['/]name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::[expr.oclAsType(MoCCMLExpression).type.eClass().name/]).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					[else]
					_abstract := seqOfExpressionDeclaration['['/]name = '[expr.type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					[/if]
				};
				[if (expr.oclAsType(MoCCMLExpression).type.oclIsKindOf(KernelExpressionDeclaration) or expr.oclAsType(MoCCMLExpression).type.oclAsType(ExpressionDeclaration).parameters->size() > 1) ]
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements['['/]name = getNameOrUID(an.oclAsType(EObject))+'_[expr.oclAsType(MoCCMLExpression).parameters->at(1).prettyPrintOnlyLast()/]'[']'/]->first();
					
					[if (expr.oclAsType(MoCCMLExpression).type.oclIsKindOf(KernelExpressionDeclaration))]
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration['['/]name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::[expr.oclAsType(MoCCMLExpression).type.eClass().name/]).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					[else]
					_abstract := seqOfAbstractEntity['['/]name = '[expr.oclAsType(MoCCMLExpression).type.oclAsType(ExpressionDeclaration).parameters->at(1).name/]' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first();
					[/if]
				};
				[/if]
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM[expr.getinMMindex()/]::[expr.getClassifierContext()/]::[expr.parent.oclAsType(LetVariableCS).name/]2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{
		//from defs
		[expr.createVarFromDefs()/]
		//from lets
		[expr.createVarFromLets()/]

		[let navSet : String = expr.oclAsType(MoCCMLExpression).parameters->at(1).prettyPrintButLast()]
		var sources : Sequence([expr.oclAsType(MoCCMLExpression).parameters->at(1).getTypeOfSet()/]) := [navSet.first(navSet.size()-1)/]->asSequence();
		[/let]
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_[expr.parent.oclAsType(LetVariableCS).name/]2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_[expr.parent.oclAsType(LetVariableCS).name/]2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_[expr.parent.oclAsType(LetVariableCS).name/]2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}

	[else]
	mapping inMM[expr.getinMMindex()/]::[expr.getClassifierContext()/]::[expr.parent.oclAsType(LetVariableCS).name/]2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_[expr.oclAsType(MoCCMLExpression).type.name/]_[expr.parent.oclAsType(LetVariableCS).name/]';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "[expr.type.name/]")->first();
		//from defs
		[expr.createVarFromDefs()/]
		//from lets
		[expr.createVarFromLets()/]

		[for (p : ExpCS | expr.oclAsType(MoCCMLExpression).parameters)]
				[let paramNumber : EInt = i]
				[comment]p only last : [p.prettyPrintOnlyLast()/]
				p but last : [p.prettyPrintButLast()/][/comment]
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				[if (isAlreadyTranslated(aMoCCMLMappingDoc.ownedPackages.ownedContexts.eAllContents(DefCS)->asOrderedSet(), p.prettyPrintOnlyLast()))]
				[comment][p/]  exists[/comment]
					bindable := theMainBlock.elements['['/]name = getNameOrUID([p.prettyPrintButLast()/]oclAsType(EObject))+'_[p.prettyPrintOnlyLast()/]'[']'/]->first();
				[else]
				[comment][p/]  to map[/comment]
				[comment]WARNING, sometimes the let is just a query to a def that exists. so lets check if the result of the init expression exists[/comment]
					[let allLetExpr : Sequence(LetExpCS) = aMoCCMLMappingDoc.eAllContents(LetExpCS)]
					[let itsVar : LetVariableCS = allLetExpr->select(e | e.oclAsType(LetExpCS).ownedVariables->asSequence()->first().name = p.prettyPrintOnlyLast())->first().ownedVariables->first()]
					[if (isAlreadyTranslated(aMoCCMLMappingDoc.ownedPackages.ownedContexts.eAllContents(DefCS)->asOrderedSet(), itsVar.ownedInitExpression.prettyPrintOnlyLast()))]
					bindable := theMainBlock.elements['['/]name = getNameOrUID([itsVar.ownedInitExpression.prettyPrintButLast()/]oclAsType(EObject))+'_[itsVar.ownedInitExpression.prettyPrintOnlyLast()/]'[']'/]->first();
					[else]
						[if (itsVar.ownedInitExpression.oclIsKindOf(MoCCMLExpression))]
					bindable := self -> map [itsVar.name/]2Expression()->asSequence()->first();
						[else]
							[if (itsVar.ownedInitExpression.toString().endsWith('()'))]
[comment]here we suppose that if it ends with () it is a functional call and then it could be that the element has no name attribute... TO FIX correctly ![/comment]
								bindable := [itsVar.ownedInitExpression/] -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+[itsVar.ownedInitExpression.prettyPrintButLast().substring(1, itsVar.ownedInitExpression.prettyPrintButLast().size()-1)/].toString()+"_[itsVar.ownedInitExpression.prettyPrintOnlyLast()/]")->asSequence()->first();
							[else]
								bindable := [itsVar.ownedInitExpression/] -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+getNameOrUID([itsVar.ownedInitExpression.prettyPrintButLast()/]oclAsType(EObject))+"_[itsVar.ownedInitExpression.prettyPrintOnlyLast()/]")->asSequence()->first();
							[/if]
						[/if]
					[/if]
					[/let][/let]
				[/if]
				[if (expr.oclAsType(MoCCMLExpression).type.oclIsKindOf(KernelExpressionDeclaration))]
[comment]					boring stuff complete[/comment]
[comment]					seqOfExpressionDeclaration['['/]name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::[expr.oclAsType(MoCCMLExpression).type.eClass().name/]).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->at([paramNumber/]).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity).name;[/comment]
				//	var size : Integer = seqOfExpressionDeclaration['['/]name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::[expr.oclAsType(MoCCMLExpression).type.eClass().name/]).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence()->size()+1;
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration['['/]name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::[expr.oclAsType(MoCCMLExpression).type.eClass().name/]).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at([paramNumber/]).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				[else]
					_abstract := seqOfAbstractEntity['['/]name = '[expr.oclAsType(MoCCMLExpression).type.oclAsType(ExpressionDeclaration).parameters->at(paramNumber).name/]' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = '[expr.oclAsType(MoCCMLExpression).type.name/]'[']'/]->first();
				[/if]
				};
				[/let]
			[/for]
		end{
			theMainBlock.expressions += result;
		}
	}
	[/if]
	[/for]



[comment]	create clock mapping [/comment] 
[for (itsContext : ContextDeclCS | aMoCCMLMappingDoc.ownedPackages.ownedContexts)]
	[for (constraint : DefCS | itsContext.eAllContents(DefCS))]
		[if (constraint.ownedType <> null and constraint.ownedType.oclIsTypeOf(EventType))]
	 	mapping inMM[itsContext.getinMMindex()/]::[itsContext.pivot.oclAsType(NamedElement).name/]::[constraint.pivot.oclAsType(NamedElement).name/]2Clock() :TimeModel::Clock 
		[if constraint.oclIsKindOf(MoCCMLMappingDefCS) ]
			when { [constraint.oclAsType(MoCCMLMappingDefCS).condition/] }
		[/if]
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_[constraint.pivot.oclAsType(NamedElement).name/]';
			tickingEvent := object TimeModel::Event{
			[comment]is there a better way to know if it is linked to an eoperation ?[/comment]
			[if (constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.toString().endsWith('()')) ]
 				referencedObjectRefs += [constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.prettyPrintButLastNoPoint()/]oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				[let start : EInt = constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.toString().lastIndexOf('.')]
			 	[let stop : EInt = constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.toString().lastIndexOf('(')]
				referencedObjectRefs += [constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.prettyPrintButLast()/]oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "[constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.toString().substring(start+1, stop-1)/]")->first().oclAsType(EObject);
				[/let]
				[/let]	
			[else]
			  [if ( constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression <> null) ]
 				referencedObjectRefs += [constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression/].oclAsType(EObject);
			  [/if]
			[/if]
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_[constraint.pivot.oclAsType(NamedElement).name/]';
			[if (constraint.ownedType.oclAsType(EventType).referedElement = null)]	
			kind := TimeModel::EventKind::undefined;
			[/if]
[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::consume)]
			kind :=TimeModel::EventKind::consume;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::create)]
			kind :=TimeModel::EventKind::create;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::destroy)]
			kind :=TimeModel::EventKind::destroy;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::finish)]
			kind :=TimeModel::EventKind::finish;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::produce)]
			kind :=TimeModel::EventKind::produce;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::receive)]
			kind :=TimeModel::EventKind::receive;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::resume)]
			kind :=TimeModel::EventKind::resume;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::send)]
			kind :=TimeModel::EventKind::send;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::start)]
			kind :=TimeModel::EventKind::start;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::suspend)]
			kind :=TimeModel::EventKind::suspend;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::undefined)]
			kind :=TimeModel::EventKind::undefined;
							[/if]
						[if (constraint.ownedType.oclAsType(EventType).referedElement <> null and constraint.ownedType.oclAsType(EventType).referedElement = moccml_mapping::EventKind::call)]
			kind :=TimeModel::EventKind::start;
							[/if]
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
		[comment]end if it is a def of event[/comment]
		[/if]
			[if (constraint.ownedType <> null and constraint.ownedType.oclIsKindOf(PrimitiveTypeRefCS) and constraint.ownedType.oclAsType(PrimitiveTypeRefCS).name = 'Integer')]
		mapping inMM[itsContext.getinMMindex()/]::[itsContext.pivot.oclAsType(NamedElement).name/]::[constraint.pivot.oclAsType(NamedElement).name/]2Integer() :TimeModel::BasicType::IntegerElement
		[if constraint.oclIsKindOf(MoCCMLMappingDefCS) ]
			when { [constraint.oclAsType(MoCCMLMappingDefCS).condition/] }
		[/if]
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_[constraint.pivot.oclAsType(NamedElement).name/]';
			type:= Kernel_Integer;
			value := [constraint.ownedSpecification/];

			end{
				theMainBlock.elements += result;
			}
		}
		[comment]end if it is a def of Integer[/comment]
		[/if]
	[comment]end for all DefCS[/comment]
 	[/for]

//relation stuff		
	[for (constraint : ConstraintCS | itsContext.eAllContents(ConstraintCS))]
	[for (expr : ExpCS | constraint.ownedSpecification.oclAsType(EObject).eAllContents(ExpCS))]	
	[if (expr.oclIsKindOf(MoCCMLRelation))] [comment]TOFIX: here expr becomes a relation and is named expr !! ouch ![/comment]
	
	[if expr.oclAsType(MoCCMLRelation).parameters->size() = 1 and expr.oclAsType(MoCCMLRelation).parameters->at(1).isACollection()] 
 [comment]called on a collection[/comment]

//Create an intermediate relation
	mapping inMM[expr.getinMMindex()/]::[expr.getClassifierContext()/]::intermediate_[expr.ancestors(ConstraintCS)->first().name+i/]2[constraint.name/](an1 : [expr.oclAsType(MoCCMLRelation).parameters->at(1).getTypeOfSet()/], an2 : [expr.oclAsType(MoCCMLRelation).parameters->at(1).getTypeOfSet()/], nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_[expr.ancestors(ConstraintCS)->first().name/]'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration['['/]name = '[expr.oclAsType(MoCCMLRelation).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::[expr.oclAsType(MoCCMLRelation).type.eClass().name/]).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "[expr.oclAsType(MoCCMLRelation).type.name/]")->first();
		[expr.createVarFromDefs()/]
		[expr.createVarFromLets()/]

					bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements['['/]name = getNameOrUID(an1.oclAsType(EObject))+'_[expr.oclAsType(MoCCMLRelation).parameters->at(1).prettyPrintOnlyLast()/]'[']'/]->first();
					[if (expr.oclAsType(MoCCMLRelation).type.oclIsKindOf(KernelRelationDeclaration))]
						_abstract := seqOfRelationDeclaration['['/]name = '[expr.oclAsType(MoCCMLRelation).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
					[else]
						_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					[/if]	

				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements['['/]name = getNameOrUID(an2.oclAsType(EObject))+'_[expr.oclAsType(MoCCMLRelation).parameters->at(1).prettyPrintOnlyLast()/]'[']'/]->first();
					[if (expr.oclAsType(MoCCMLRelation).type.oclIsKindOf(KernelRelationDeclaration))]
						_abstract := seqOfRelationDeclaration['['/]name = '[expr.oclAsType(MoCCMLRelation).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
					[else]
						_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					[/if]	

				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM[expr.getinMMindex()/]::[expr.getClassifierContext()/]::[expr.ancestors(ConstraintCS)->first().name+i/]2[constraint.name/]()
	[if (expr.getAllContainingExpression()->filter(InfixExpCS)->size() > 0)]
		[let theImpliesOp :InfixExpCS = expr.getAllContainingExpression()->filter(InfixExpCS)->select( ie | ie.name='implies')->first()] 
			[if not theImpliesOp.oclIsUndefined() ]
			when { 
				[expr.createLetFromDefs()/]
				[if (theImpliesOp.parent.oclIsKindOf(LetExpCS))][comment it depends if the let are included in le left of implies or not (i.e., on parenthesis) /]
					[expr.createLetFromLets()/]
				[/if]
				[theImpliesOp.ownedLeft/] 
			}
			[/if]
		[/let]
	[/if]	
	{
		init{
			[expr.createVarFromDefs()/]
			[expr.createVarFromLets()/]
			[let navSet : String = expr.oclAsType(MoCCMLRelation).parameters->at(1).prettyPrintButLast()]
			var sources : Sequence([expr.oclAsType(MoCCMLRelation).parameters->at(1).getTypeOfSet()/]) := [navSet.first(navSet.size()-1)/]->asSequence();
			[/let]
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_[expr.ancestors(ConstraintCS)->first().name+i/]2[constraint.name/](sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

	[else]
		mapping inMM[expr.getinMMindex()/]::[itsContext.pivot.oclAsType(NamedElement).name/]::[expr.ancestors(ConstraintCS)->first().name+i/]2[constraint.name/]([expr.eContainer(InfixExpCS).prettyPrintParametersForDefinition()/]): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		[if (expr.getAllContainingExpression()->filter(InfixExpCS)->size() > 0)]
		[let theImpliesOp :InfixExpCS = expr.getAllContainingExpression()->filter(InfixExpCS)->select( ie | ie.name='implies')->first()] 
			[if not theImpliesOp.oclIsUndefined() ]
			when { 
				[expr.createLetFromDefs()/]
				[if (theImpliesOp.parent.oclIsKindOf(LetExpCS))][comment it depends if the let are included in le left of implies or not (i.e., on parenthesis) /]
					[expr.createLetFromLets()/]
				[/if]
				[theImpliesOp.ownedLeft/] 
				
}
			[/if]
		[/let]
		[/if]	
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"[expr.oclAsType(MoCCMLRelation).type.name/]_[constraint.name/]";
			[comment]The Expr : [expr/][/comment]
			type := seqOfRelationDeclaration->select(rd | rd.name = "[expr.oclAsType(MoCCMLRelation).type.name/]")->first();
			[expr.createVarFromDefs()/]
			[expr.createVarFromLets()/]
			[let allLetExpr : Sequence(LetExpCS) = expr.ancestors(ConstraintCS)->first().oclAsType(EObject).eAllContents(LetExpCS)->select(l  | true)]
			[for (p : ExpCS | expr.oclAsType(MoCCMLRelation).parameters)]
				[let paramNumber : EInt = i]
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
				[if (isAlreadyTranslated(aMoCCMLMappingDoc.ownedPackages.ownedContexts.eAllContents(DefCS)->asOrderedSet(), p.prettyPrintOnlyLast()))]
					bindable := theMainBlock.elements['['/]name = getNameOrUID([p.prettyPrintButLast()/]oclAsType(EObject))+'_[p.prettyPrintOnlyLast()/]'[']'/]->first();
				[else]
					[let itsVar : LetVariableCS = allLetExpr->select(e | e.oclAsType(LetExpCS).ownedVariables->asSequence()->first().name = p.prettyPrintOnlyLast())->first().ownedVariables->first()]
					[comment]sometimes the let is just a query to a def that exists. so lets check if the result of the init expression exists[/comment]
	[comment]				If it is an event, we do MoCCMLMapping stuff
					--WARNING for now if an Int we both translate it into a CCSL int and a QVTo Var[/comment]
					[if (itsVar.ownedType.oclIsKindOf(EventType) or itsVar.ownedType.pivot.oclAsType(NamedElement).name = 'Integer')]
						[if (isAlreadyTranslated(aMoCCMLMappingDoc.ownedPackages.ownedContexts.eAllContents(DefCS)->asOrderedSet(), itsVar.ownedInitExpression.prettyPrintOnlyLast()))]
							bindable := theMainBlock.elements['['/]name = getNameOrUID([itsVar.ownedInitExpression.prettyPrintButLast()/]oclAsType(EObject))+'_[itsVar.ownedInitExpression.prettyPrintOnlyLast()/]'[']'/]->first();
							[else]
								[if (itsVar.ownedInitExpression.oclIsKindOf(MoCCMLExpression))]
							bindable := self -> map [itsVar.name/]2Expression()->asSequence()->first();
								[else]
									[if (itsVar.ownedInitExpression.toString().endsWith('()'))]
[comment]here we suppose that if it ends with () it is a functional call and then it could be that the element has no name attribute... TO FIX correctly ![/comment]
							bindable := [itsVar.ownedInitExpression/] -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+[itsVar.ownedInitExpression.prettyPrintButLast().substring(0, itsVar.ownedInitExpression.prettyPrintButLast().size()-1)/].toString()+"_[itsVar.ownedInitExpression.prettyPrintOnlyLast()/]")->asSequence()->first();
									[else]
							bindable := [itsVar.ownedInitExpression/] -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+getNameOrUID([itsVar.ownedInitExpression.prettyPrintButLast()/]oclAsType(EObject))+"_[itsVar.ownedInitExpression.prettyPrintOnlyLast()/]")->asSequence()->first();
									[/if]							
								[/if]
							[/if]
					[comment]if not an event, we created a var before[/comment]
					[/if]
					[/let]
				[/if]
				[if (expr.oclAsType(MoCCMLRelation).type.oclIsKindOf(KernelRelationDeclaration))]
					[if (paramNumber=1)]
					_abstract := seqOfRelationDeclaration['['/]name = '[expr.oclAsType(MoCCMLRelation).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
					[else]
					_abstract := seqOfRelationDeclaration['['/]name = '[expr.oclAsType(MoCCMLRelation).type.name/]'[']'/]->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
					[/if]
				[else]
					_abstract := seqOfAbstractEntity['['/]name = '[expr.oclAsType(MoCCMLRelation).type.oclAsType(RelationDeclaration).parameters->at(paramNumber).name/]'[']'/]->first();
				[/if]
				};
				[/let]
			[/for]
			[/let]
		
		theMainBlock.relations += result;
		}
		[/if]
	[else]
[comment]		ELSE not (expr.oclIsKindOf(MoCCMLRelation))[/comment]
	[/if] 
	[/for]
		
	[/for]
[/for]




















[comment]FeedBack stuff ![/comment]

mapping inMM[getpackageIndex(aMoCCMLMappingDoc, rootElementName)/]::[rootElementName/]::[aMoCCMLMappingDoc.ownedPackages->asSequence()->first().pivot.oclAsType(NamedElement).name/]2FeedBack() : FeedBack::ActionModel {
	    theFeedBackSpec := result;
		importStatements+= object FeedBack::ImportStatement{
			importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
		}; 
	[for (itsContext : ContextDeclCS | aMoCCMLMappingDoc.ownedPackages.ownedContexts)]
[comment]MSE[/comment]
	[for (constraint : DefCS | itsContext.eAllContents(DefCS))]
		[if (constraint.ownedType <> null and constraint.ownedType.oclIsTypeOf(EventType))] 
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), [itsContext.pivot.oclAsType(NamedElement).name/].oclAsType(EClass)).oclAsType([itsContext.pivot.oclAsType(NamedElement).name/])->map [constraint.pivot.oclAsType(NamedElement).name/]2MSE();
	[comment]inM.rootObjects().allSubobjects()->including(self)[ '[' /] [itsContext.pivot.oclAsType(NamedElement).name/] [ ']' /]->map [constraint.pivot.oclAsType(NamedElement).name/]2MSE();[/comment]
		[/if]
	[/for]
[comment]When future[/comment]
	[for (constraint : DefCS | itsContext.eAllContents(DefCS))]
			[if (constraint.ownedType <> null and constraint.ownedType.oclIsTypeOf(EventType) and constraint.oclIsTypeOf(MoCCMLMappingEventDefCS) and constraint.oclAsType(MoCCMLMappingEventDefCS).future <> null)] 
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), [itsContext.pivot.oclAsType(NamedElement).name/].oclAsType(EClass)).oclAsType([itsContext.pivot.oclAsType(NamedElement).name/])->map [constraint.pivot.oclAsType(NamedElement).name/]2Future();
	[comment]inM.rootObjects().allSubobjects()->including(self)[ '[' /] [itsContext.pivot.oclAsType(NamedElement).name/] [ ']' /]->map [constraint.pivot.oclAsType(NamedElement).name/]2Future();[/comment]
			[/if]
	[/for]
[comment]When feedback[/comment]
	[for (constraint : DefCS | itsContext.eAllContents(DefCS))]
			[if (constraint.ownedType <> null and constraint.ownedType.oclIsTypeOf(EventType) and constraint.oclIsTypeOf(MoCCMLMappingEventDefCS) and constraint.oclAsType(MoCCMLMappingEventDefCS).feedback <> null)] 
			[for (case : Case | constraint.oclAsType(MoCCMLMappingEventDefCS).feedback.cases )]
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), [itsContext.pivot.oclAsType(NamedElement).name/].oclAsType(EClass)).oclAsType([itsContext.pivot.oclAsType(NamedElement).name/])->map [constraint.pivot.oclAsType(NamedElement).name+i/]2ActionFeedBack();
	[comment]inM.rootObjects().allSubobjects()->including(self)[ '[' /] [itsContext.pivot.oclAsType(NamedElement).name/] [ ']' /]->map [constraint.pivot.oclAsType(NamedElement).name+i/]2ActionFeedBack();[/comment]
			[/for]
			[/if]
	[/for]
[comment]TODO deal with blocks[/comment]
[/for]
}		


[for (itsContext : ContextDeclCS | aMoCCMLMappingDoc.ownedPackages.ownedContexts)]
	[for (constraint : DefCS | itsContext.eAllContents(DefCS))]
		[if (constraint.ownedType <> null and constraint.ownedType.oclIsTypeOf(EventType))]
	 	mapping inMM[itsContext.getinMMindex()/]::[itsContext.pivot.oclAsType(NamedElement).name/]::[constraint.pivot.oclAsType(NamedElement).name/]2MSE() :FeedBack::ModelSpecificEvent 
		[if (constraint.oclIsKindOf(MoCCMLMappingDefCS)) ]
			when { [constraint.oclAsType(MoCCMLMappingDefCS).condition/] }
		[/if]
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_[constraint.pivot.oclAsType(NamedElement).name/]';

			[if ((constraint.oclIsTypeOf(DefPropertyCS) and constraint.toString().contains('Event')) or (constraint.oclIsKindOf(MoCCMLMappingDefCS)))]
				[if ((constraint.oclIsTypeOf(DefPropertyCS) and constraint.oclAsType(DefPropertyCS).ownedSpecification.toString().endsWith('()'))
					 or 
					 (constraint.oclIsKindOf(MoCCMLMappingDefCS) and constraint.oclAsType(MoCCMLMappingDefCS).ownedSpecification.toString().endsWith('()')))]
				caller := [constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.prettyPrintButLastNoPoint()/]oclAsType(EObject);
				[let start : EInt = constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.toString().lastIndexOf('.')]
				[let stop : EInt = constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.toString().lastIndexOf('(')]
				action := [constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.prettyPrintButLast()/]oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "[constraint.ownedSpecification.oclAsType(ExpSpecificationCS).ownedExpression.toString().substring(start+1, stop-1)/]")->first();
				[/let]
				[/let]
				[/if]
				solverEvent := theMainBlock.elements['['/]TimeModel::Clock[']'/]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_[constraint.pivot.oclAsType(NamedElement).name/]')->first().oclAsType(EObject);
				
			[/if]
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
		[/if]
	[/for]
[/for]
			
		
[for (itsContext : ContextDeclCS | aMoCCMLMappingDoc.ownedPackages.ownedContexts)]
	[for (constraint : DefCS | itsContext.eAllContents(DefCS))]
		[if (constraint.ownedType <> null and constraint.ownedType.oclIsTypeOf(EventType)  and constraint.oclIsTypeOf(MoCCMLMappingEventDefCS) and constraint.oclAsType(MoCCMLMappingEventDefCS).future <> null)]
	 	mapping inMM[itsContext.getinMMindex()/]::[itsContext.pivot.oclAsType(NamedElement).name/]::[constraint.pivot.oclAsType(NamedElement).name/]2Future() :FeedBack::When 
		[if (constraint.oclIsKindOf(MoCCMLMappingDefCS)) ]
			when { [constraint.oclAsType(MoCCMLMappingDefCS).condition/] }
		[/if]
		{
			action := object FeedBack::Force{
				kind := ForceKind::Presence;
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID([constraint.oclAsType(MoCCMLMappingEventDefCS).future.prettyPrintButLast()/]oclAsType(EObject))+'_[constraint.oclAsType(MoCCMLMappingEventDefCS).future.prettyPrintOnlyLast()/]')->first()
			};
			condition := object FeedBack::ActionFinishedCondition{
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+self.name+'_[constraint.oclAsType(MoCCMLMappingEventDefCS).name/]')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}
		}
		[/if]
	[/for]
[/for]


[for (itsContext : ContextDeclCS | aMoCCMLMappingDoc.ownedPackages.ownedContexts)]
	[for (constraint : DefCS | itsContext.eAllContents(DefCS))]
		[if (constraint.ownedType <> null and constraint.ownedType.oclIsTypeOf(EventType)  and constraint.oclIsTypeOf(MoCCMLMappingEventDefCS) and constraint.oclAsType(MoCCMLMappingEventDefCS).feedback <> null)]
	 	[for (case : Case | constraint.oclAsType(MoCCMLMappingEventDefCS).feedback.cases )]
		mapping inMM[itsContext.getinMMindex()/]::[itsContext.pivot.oclAsType(NamedElement).name/]::[constraint.pivot.oclAsType(NamedElement).name+i/]2ActionFeedBack() :FeedBack::When 
		[if (constraint.oclIsKindOf(MoCCMLMappingDefCS)) ]
			when { [constraint.oclAsType(MoCCMLMappingDefCS).condition/] }
		[/if]
		{
			action := object FeedBack::Force{
				[if (case.kindOfFeedback = FeedBackKind::force)]
				kind := ForceKind::Presence;
				[if (case.on <> null)]
				onTrigger := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID([case.on.prettyPrintButLast()/]oclAsType(EObject))+'_[case.on.prettyPrintOnlyLast()/]')->first();
				[/if]
				[/if]
				[if (case.kindOfFeedback = FeedBackKind::forbid)]
				kind := ForceKind::Absence;
				untilTrigger := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID([case.on.prettyPrintButLast()/]oclAsType(EObject))+'_[case.on.prettyPrintOnlyLast()/]')->first();
[comment][case.on/].resolveone(ModelSpecificEvent);[/comment]
				[/if]
				eventToBeForced := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID([case.eventToForce.prettyPrintButLast()/]oclAsType(EObject))+'_[case.eventToForce.prettyPrintOnlyLast()/]')->first();
				
			};
			condition := object FeedBack::ActionResultCondition{
				[let op : String = case.condition.oclAsType(NestedExpCS).ownedExpression.oclAsType(InfixExpCS).name]
				[if (op = '=')]
				operator := ComparisonOperator::equals;
				[/if]
				[if (op = '<>')]
				operator := ComparisonOperator::different;
				[/if]
[comment]				[if (case.condition.oclAsType(InfixExpCS).ownedOperator->last().toString() = '<')] [/comment]
				[if (op = '<')] 
				operator := ComparisonOperator::inf;
				[/if]
				[if (op = '>')]
				operator := ComparisonOperator::sup;
				[/if]
				[if (op = '<=')]
				operator := ComparisonOperator::infEquals;
				[/if]
				[if (op = '>=')]
				operator := ComparisonOperator::supEquals;
				[/if]
				[/let]
				comparisonValue := [case.condition.oclAsType(NestedExpCS).ownedExpression.oclAsType(InfixExpCS).ownedRight/];
			};
			source := seqOfMSE->select(mse | mse.name = 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_[constraint.oclAsType(MoCCMLMappingEventDefCS).name/]')->first();
			
			end{
				theFeedBackSpec.whenStatements += result;
			}

		}
		[/for]
		[/if]
	[/for]
[/for]




[comment]Priority  stuff ![/comment]
//priority stuff

mapping inMM[getpackageIndex(aMoCCMLMappingDoc, rootElementName)/]::[rootElementName/]::[aMoCCMLMappingDoc.ownedPackages->asSequence()->first().pivot.oclAsType(NamedElement).name/]2Priority()  :Priority::PrioritySpecification  {
	thePrioritySpec := result;
	importedModel := object Priority::ImportStatement{
		importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
	}; 
	[for (itsContext : ContextDeclCS | aMoCCMLMappingDoc.ownedPackages.ownedContexts)]
[comment]MSE[/comment]
		[for (constraint : ConstraintCS | itsContext.eAllContents(ConstraintCS))]
			[for (expr : ExpCS | constraint.ownedSpecification.eAllContents(ExpCS))]	
				[if (expr.oclIsKindOf(MoCCMLMappingPriority))]
					[if not expr.eContainer(NavigatingArgCS).oclIsUndefined() ]
						[let navStringWithoutRelation : String = expr.eContainer(InfixExpCS).prettyPrintButRelation()]
						[let navStringWithoutRelationNorSelf : String = if(navStringWithoutRelation.contains('self.')) then navStringWithoutRelation.substring(6) else navStringWithoutRelation endif]
						[let correctString : String = navStringWithoutRelationNorSelf.substitute('StringToReplaceWithTheMapping', 'not ( a.map '+itsContext.pivot.oclAsType(NamedElement).name+expr.pivot.oclAsType(NamedElement).name+i+'2'+constraint.name)]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), [itsContext.pivot.oclAsType(NamedElement).name/].oclAsType(EClass))
					->forAll(a | a.[correctString/]);
						[/let]
						[/let]
						[/let]
					[else]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), [itsContext.pivot.oclAsType(NamedElement).name/].oclAsType(EClass)).oclAsType([itsContext.pivot.oclAsType(NamedElement).name/])->map [expr.ancestors(ConstraintCS)->first().name+i/]2[constraint.name/]();
					[/if]
				[/if]
			[/for]
		[/for]
[comment]TODO deal with blocks[/comment]
	[/for]
}	

	[for (itsContext : ContextDeclCS | aMoCCMLMappingDoc.ownedPackages.ownedContexts)]
[comment]MSE[/comment]
		[for (constraint : ConstraintCS | itsContext.eAllContents(ConstraintCS))]
			[for (expr : ExpCS | constraint.ownedSpecification.eAllContents(ExpCS))]	
				[if (expr.oclIsKindOf(MoCCMLMappingPriority))]
		mapping inMM[itsContext.getinMMindex()/]::[itsContext.pivot.oclAsType(NamedElement).name/]::[constraint.pivot.oclAsType(NamedElement).name+i/]2[constraint.name/]() :Priority::PriorityRelation 
					[if (expr.getAllContainingExpression()->filter(InfixExpCS)->size() > 0)]
					[let theImpliesOp :InfixExpCS = expr.getAllContainingExpression()->filter(InfixExpCS)->select( ie | ie.name='implies')->first()] 
						[if not theImpliesOp.oclIsUndefined() ]
			when { 
							[for (letExp : LetExpCS | theImpliesOp.getAllLetExpParents()) ]
						  let [letExp.ownedVariables.toString()/] in
							[/for]
							[theImpliesOp.ownedLeft/] 
							
						}
						[/if]
					[/let]
					[/if]	
		{
					[let allLetExpr : Sequence(LetExpCS) = expr.ancestors(ConstraintCS)->first().oclAsType(EObject).eAllContents(LetExpCS)->select(l  | true)]
		[comment]			look if let is just a query to make the code cleaner --WARNING for now if an Int we both translate it into a CCSL int and a QVTo var[/comment]
					[for (aVar : LetVariableCS | allLetExpr.ownedVariables)]
						[if (not aVar.ownedType.oclIsKindOf(EventType))]	
			var [aVar.name/] : [aVar.ownedType/] := [aVar.ownedInitExpression/];
						[/if]
					[/for]
					[/let]
					[let p1 : ExpCS = expr.oclAsType(MoCCMLMappingPriority).lower]
					[let p2 : ExpCS = expr.oclAsType(MoCCMLMappingPriority).higher]
			lower  := theMainBlock.elements['['/]name = getNameOrUID([p1.prettyPrintButLast()/]oclAsType(EObject))+'_[p1.prettyPrintOnlyLast()/]'[']'/]->first();
			higher := theMainBlock.elements['['/]name = getNameOrUID([p2.prettyPrintButLast()/]oclAsType(EObject))+'_[p2.prettyPrintOnlyLast()/]'[']'/]->first();
			end{
				thePrioritySpec.relations += result;
			}
		}
					[/let]
					[/let]
				[/if]
			[/for]
		[/for]
[comment]TODO deal with blocks[/comment]
	[/for]



[/file]
[/let]
[/template]

[template public createVarFromDefs (expr : ExpCS) ][comment warning we retrieve only defs of the classifier, not the one from its superClasses./]
		[let allDef : Sequence(DefCS) = expr.ancestors(ClassifierContextDeclCS)->first().oclAsType(EObject).eAllContents(DefCS)->select(l  | not l.oclAsType(DefCS).ownedType.oclIsTypeOf(EventType))]
			[for (aVar : DefCS | allDef)]
		var [aVar.name/] : [aVar.ownedType/] := [aVar.ownedSpecification/];
			[/for]
		[/let]		 
[/template]
[template public createVarFromLets (expr : ExpCS) ]
		[let allLetExpr : Sequence(LetExpCS) = expr.ancestors(ConstraintCS)->first().oclAsType(EObject).eAllContents(LetExpCS)]
[comment]			look if let is just a query to make the code cleaner --WARNING for now if an Int we both translate it into a CCSL int and a QVTo var[/comment]
			[for (aVar : LetVariableCS | allLetExpr.ownedVariables)]
				[if aVar.ownedType <> null and (not aVar.ownedType.oclIsKindOf(EventType))]	
		var [aVar.name/] : [aVar.ownedType/] := [aVar.ownedInitExpression/];
				[/if]
			[if aVar.ownedType = null]
		var [aVar.name/] := [aVar.ownedInitExpression/];
			[/if]
			[/for]
		[/let] 
[/template]

[template public createLetFromDefs (expr : ExpCS) ]
		[let allDef : Sequence(DefCS) = expr.ancestors(ClassifierContextDeclCS)->first().oclAsType(EObject).eAllContents(DefCS)->select(l  | not l.oclAsType(DefCS).ownedType.oclIsTypeOf(EventType))]
			[for (aVar : DefCS | allDef)]
		let [aVar.name/] : [aVar.ownedType/] = [aVar.ownedSpecification/] in
			[/for]
		[/let]		 
[/template]
[template public createLetFromLets (expr : ExpCS) ]
		[let allLetExpr : Sequence(LetExpCS) = expr.ancestors(ConstraintCS)->first().oclAsType(EObject).eAllContents(LetExpCS)]
[comment]			look if let is just a query to make the code cleaner --WARNING for now if an Int we both translate it into a CCSL int and a QVTo var[/comment]
			[for (aVar : LetVariableCS | allLetExpr.ownedVariables)]
				[if aVar.ownedType <> null and (not aVar.ownedType.oclIsKindOf(EventType))]	
		let [aVar.name/] : [aVar.ownedType/] = [aVar.ownedInitExpression/] in
				[/if]
			[if aVar.ownedType = null]
		let [aVar.name/] = [aVar.ownedInitExpression/] in
			[/if]
			[/for]
		[/let] 
[/template]

[template public getinMMindex(anObject:EObject)]
[for (p: PackageDeclarationCS | anObject.eContainer(MoCCMLMappingDocument).ownedPackages)]
	[if (anObject.eContainer(PackageDeclarationCS)->asSequence()->first() = p)]
[i/][/if]
[/for]
[/template]


[comment][query public getCCSLTypeOf(aType: TypeRefCS): String =
if (aType.oclIsKindOf(PrimitiveTypeRefCS)) then
	TimeModel::BasicType::IntegerElement
else
	TimeModel::Clock
endif
/][/comment]

[query public getClassifierContext(elem : ElementCS) : String =
invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'getClassifierContext(org.eclipse.ocl.xtext.basecs.ElementCS)', Sequence{elem})/]

[query public getElementsFromLib(libPath : String) : Set(EObject) = 
invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'getElementsFromLib(java.util.String)', Sequence{libPath}) /]
 
[comment][query public getAllContainedExpresion(arg0 : EObject) : Sequence(ExpCS)
	= invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'getAllContainedExpression(org.eclipse.emf.ecore.EObject)', Sequence{arg0}) /][/comment]

[query public getAllContainingExpression(arg0 : EObject) : Sequence(ExpCS)
	= invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'getAllContainingExpression(org.eclipse.emf.ecore.EObject)', Sequence{arg0}) /]

[query public getAllLetExpParents(arg0 : EObject) : Sequence(LetExpCS)
	= invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'getAllLetExpParents(org.eclipse.emf.ecore.EObject)', Sequence{arg0}) /]

[query public prettyPrintButLast(constraint : ExpCS) : String =
invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'prettyPrintButLast(org.eclipse.ocl.xtext.essentialoclcs.ExpCS)', Sequence{constraint})/]

[query public prettyPrintButLastNoPoint(constraint : ExpCS) : String =
invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'prettyPrintButLast(org.eclipse.ocl.xtext.essentialoclcs.ExpCS)', Sequence{constraint})/]

 

[query public prettyPrintOnlyLast(constraint : ExpCS) : String =
invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'prettyPrintOnlyLast(org.eclipse.ocl.xtext.essentialoclcs.ExpCS)', Sequence{constraint})/]

[query public prettyPrintButRelation(constraint : ExpCS) : String =
invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'prettyPrintButRelation(org.eclipse.ocl.xtext.essentialoclcs.ExpCS)', Sequence{constraint})/]

[query public prettyPrintParametersForDefinition(constraint : ExpCS) : String =
invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'prettyPrintParametersForDefinition(org.eclipse.ocl.xtext.essentialoclcs.ExpCS)', Sequence{constraint})/]

[query public isACollection(param : ExpCS) : Boolean =
invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'isACollection(org.eclipse.ocl.xtext.essentialoclcs.ExpCS)', Sequence{param})/]


[query public prettyPrintAlias(arg0 : String) : String
	= invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'prettyPrintAlias(java.lang.String)', Sequence{arg0}) /]

[query public getModelPath(arg0 : MoCCMLMappingDocument) : String
	= invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'getModelPath(org.eclipse.gemoc.moccml.mapping.moccml_mapping.MoCCMLMappingDocument)', Sequence{arg0}) /]

[query public getTypeOfSet(param : EObject) : String
	= invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'getTypeOfSet(org.eclipse.emf.ecore.EObject)', Sequence{param}) /]


[query public isAlreadyTranslated(defs : Set(DefCS), paramName : String) : Boolean
	= invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'isAlreadyTranslated(java.util.Set, java.lang.String)', Sequence{defs, paramName}) /]

[query public getpackageIndex(eclDoc : MoCCMLMappingDocument, objectName : String) : String
	= invoke('org.eclipse.gemoc.moccml_mapping.ecltoqvto.helper.helperNsURI', 'getpackageIndex(org.eclipse.gemoc.moccml.mapping.moccml_mapping.MoCCMLMappingDocument, java.lang.String)', Sequence{eclDoc, objectName}) /]

