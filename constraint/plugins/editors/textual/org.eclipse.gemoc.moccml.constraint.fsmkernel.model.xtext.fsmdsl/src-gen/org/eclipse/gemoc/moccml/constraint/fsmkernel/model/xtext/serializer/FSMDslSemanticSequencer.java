/*
 * generated by Xtext 2.31.0
 */
package org.eclipse.gemoc.moccml.constraint.fsmkernel.model.xtext.serializer;

import com.google.inject.Inject;
import fr.inria.aoste.timesquare.ccslkernel.library.xtext.serializer.CCSLLibrarySemanticSequencer;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.BasicTypePackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.BooleanElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Box;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Char;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.DenseClockType;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.DiscreteClockType;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.EnumerationType;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Field;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.IntegerElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Real;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.RealElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Record;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.RecordElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.SequenceElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.SequenceType;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.StringElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.And;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.BooleanRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.BooleanVariableRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.ClassicalExpressionPackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntDivide;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntEqual;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntInf;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntMinus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntMultiply;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntPlus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntSup;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntegerRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntegerVariableRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.Not;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.NumberSeqRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.NumberSeqVariableRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.Or;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealEqual;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealInf;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealMinus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealMultiply;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealPlus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealSup;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealVariableRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqDecr;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqGetHead;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqGetTail;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqIsEmpty;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqSched;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.UnaryIntMinus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.UnaryIntPlus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.UnaryRealMinus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.UnaryRealPlus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.Xor;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.AbstractEntity;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.Binding;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ClockExpressionAndRelationPackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ConditionalExpressionDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ConditionalRelationDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExprCase;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.Expression;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExpressionDeclaration;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExpressionLibrary;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExternalExpressionDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExternalRelationDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Concatenation;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Death;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Defer;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Discretization;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Inf;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Intersection;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.KernelExpressionPackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.NonStrictSampling;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.StrictSampling;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Sup;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Union;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.UpTo;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Wait;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.Coincidence;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.Exclusion;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.KernelRelationPackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.NonStrictPrecedence;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.Precedence;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.SubClock;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.Library;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.RelCase;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.Relation;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.RelationDeclaration;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.RelationLibrary;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.UserExpressionDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.UserRelationDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.Clock;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.ImportStatement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.TimeModelPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.DeclarationBlock;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.FSMModelPackage;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.Guard;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.IntegerAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.State;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.StateMachineDefinition;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.Transition;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.Trigger;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.EditionExtensionPackage;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntInfEqual;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSelfDivideAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSelfMinusAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSelfMultiplyAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSelfPlusAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSupEqual;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntegerAssignementBlock;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.xtext.services.FSMDslGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FSMDslSemanticSequencer extends CCSLLibrarySemanticSequencer {

	@Inject
	private FSMDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BasicTypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BasicTypePackage.BOOLEAN:
				sequence_Boolean(context, (fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Boolean) semanticObject); 
				return; 
			case BasicTypePackage.BOOLEAN_ELEMENT:
				sequence_BooleanElement(context, (BooleanElement) semanticObject); 
				return; 
			case BasicTypePackage.BOX:
				sequence_Box(context, (Box) semanticObject); 
				return; 
			case BasicTypePackage.CHAR:
				sequence_Char(context, (Char) semanticObject); 
				return; 
			case BasicTypePackage.DENSE_CLOCK_TYPE:
				sequence_DenseClockType(context, (DenseClockType) semanticObject); 
				return; 
			case BasicTypePackage.DISCRETE_CLOCK_TYPE:
				sequence_DiscreteClockType_Impl(context, (DiscreteClockType) semanticObject); 
				return; 
			case BasicTypePackage.ENUMERATION_TYPE:
				sequence_EnumerationType(context, (EnumerationType) semanticObject); 
				return; 
			case BasicTypePackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case BasicTypePackage.INTEGER:
				sequence_Integer(context, (fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Integer) semanticObject); 
				return; 
			case BasicTypePackage.INTEGER_ELEMENT:
				sequence_IntegerElement(context, (IntegerElement) semanticObject); 
				return; 
			case BasicTypePackage.REAL:
				sequence_Real(context, (Real) semanticObject); 
				return; 
			case BasicTypePackage.REAL_ELEMENT:
				sequence_RealElement(context, (RealElement) semanticObject); 
				return; 
			case BasicTypePackage.RECORD:
				sequence_Record(context, (Record) semanticObject); 
				return; 
			case BasicTypePackage.RECORD_ELEMENT:
				sequence_RecordElement(context, (RecordElement) semanticObject); 
				return; 
			case BasicTypePackage.SEQUENCE_ELEMENT:
				sequence_SequenceElement(context, (SequenceElement) semanticObject); 
				return; 
			case BasicTypePackage.SEQUENCE_TYPE:
				sequence_SequenceType(context, (SequenceType) semanticObject); 
				return; 
			case BasicTypePackage.STRING:
				sequence_String1(context, (fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.String) semanticObject); 
				return; 
			case BasicTypePackage.STRING_ELEMENT:
				sequence_StringElement(context, (StringElement) semanticObject); 
				return; 
			}
		else if (epackage == ClassicalExpressionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ClassicalExpressionPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case ClassicalExpressionPackage.BOOLEAN_REF:
				sequence_BooleanRef(context, (BooleanRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.BOOLEAN_VARIABLE_REF:
				sequence_BooleanVariableRef(context, (BooleanVariableRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_DIVIDE:
				sequence_IntDivide(context, (IntDivide) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_EQUAL:
				sequence_IntEqual(context, (IntEqual) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_INF:
				sequence_IntInf(context, (IntInf) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_MINUS:
				sequence_IntMinus(context, (IntMinus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_MULTIPLY:
				sequence_IntMultiply(context, (IntMultiply) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_PLUS:
				sequence_IntPlus(context, (IntPlus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_SUP:
				sequence_IntSup(context, (IntSup) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INTEGER_REF:
				sequence_IntegerRef(context, (IntegerRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INTEGER_VARIABLE_REF:
				sequence_IntegerVariableRef(context, (IntegerVariableRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case ClassicalExpressionPackage.NUMBER_SEQ_REF:
				sequence_NumberSeqRef(context, (NumberSeqRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.NUMBER_SEQ_VARIABLE_REF:
				sequence_NumberSeqVariableRef(context, (NumberSeqVariableRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_EQUAL:
				sequence_RealEqual(context, (RealEqual) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_INF:
				sequence_RealInf(context, (RealInf) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_MINUS:
				sequence_RealMinus(context, (RealMinus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_MULTIPLY:
				sequence_RealMultiply(context, (RealMultiply) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_PLUS:
				sequence_RealPlus(context, (RealPlus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_REF:
				sequence_RealRef(context, (RealRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_SUP:
				sequence_RealSup(context, (RealSup) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_VARIABLE_REF:
				sequence_RealVariableRef(context, (RealVariableRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_DECR:
				sequence_SeqDecr(context, (SeqDecr) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_GET_HEAD:
				sequence_SeqGetHead(context, (SeqGetHead) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_GET_TAIL:
				sequence_SeqGetTail(context, (SeqGetTail) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_IS_EMPTY:
				sequence_SeqIsEmpty(context, (SeqIsEmpty) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_SCHED:
				sequence_SeqSched(context, (SeqSched) semanticObject); 
				return; 
			case ClassicalExpressionPackage.UNARY_INT_MINUS:
				sequence_UnaryIntMinus(context, (UnaryIntMinus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.UNARY_INT_PLUS:
				sequence_UnaryIntPlus(context, (UnaryIntPlus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.UNARY_REAL_MINUS:
				sequence_UnaryRealMinus(context, (UnaryRealMinus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.UNARY_REAL_PLUS:
				sequence_UnaryRealPlus(context, (UnaryRealPlus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.XOR:
				sequence_Xor(context, (Xor) semanticObject); 
				return; 
			}
		else if (epackage == ClockExpressionAndRelationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ClockExpressionAndRelationPackage.ABSTRACT_ENTITY:
				sequence_AbstractEntity(context, (AbstractEntity) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.CONDITIONAL_EXPRESSION_DEFINITION:
				sequence_ConditionalExpressionDefinition(context, (ConditionalExpressionDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.CONDITIONAL_RELATION_DEFINITION:
				sequence_ConditionalRelationDefinition(context, (ConditionalRelationDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXPR_CASE:
				sequence_ExprCase(context, (ExprCase) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXPRESSION_DECLARATION:
				sequence_ExpressionDeclaration(context, (ExpressionDeclaration) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXPRESSION_LIBRARY:
				sequence_ExpressionLibrary(context, (ExpressionLibrary) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXTERNAL_EXPRESSION_DEFINITION:
				sequence_ExternalExpressionDefinition(context, (ExternalExpressionDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXTERNAL_RELATION_DEFINITION:
				sequence_ExternalRelationDefinition(context, (ExternalRelationDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.REL_CASE:
				sequence_RelCase(context, (RelCase) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.RELATION_DECLARATION:
				sequence_RelationDeclaration(context, (RelationDeclaration) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.RELATION_LIBRARY:
				sequence_RelationLibrary(context, (RelationLibrary) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.USER_EXPRESSION_DEFINITION:
				sequence_UserExpressionDefinition_Impl(context, (UserExpressionDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.USER_RELATION_DEFINITION:
				sequence_UserRelationDefinition_Impl(context, (UserRelationDefinition) semanticObject); 
				return; 
			}
		else if (epackage == FSMModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FSMModelPackage.DECLARATION_BLOCK:
				sequence_DeclarationBlock(context, (DeclarationBlock) semanticObject); 
				return; 
			case FSMModelPackage.GUARD:
				sequence_Guard(context, (Guard) semanticObject); 
				return; 
			case FSMModelPackage.INTEGER_ASSIGNEMENT:
				sequence_IntegerAssignement(context, (IntegerAssignement) semanticObject); 
				return; 
			case FSMModelPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case FSMModelPackage.STATE_MACHINE_DEFINITION:
				sequence_StateMachineDefinition(context, (StateMachineDefinition) semanticObject); 
				return; 
			case FSMModelPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case FSMModelPackage.TRIGGER:
				sequence_Trigger(context, (Trigger) semanticObject); 
				return; 
			}
		else if (epackage == KernelExpressionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KernelExpressionPackage.CONCATENATION:
				sequence_Concatenation(context, (Concatenation) semanticObject); 
				return; 
			case KernelExpressionPackage.DEATH:
				sequence_Death(context, (Death) semanticObject); 
				return; 
			case KernelExpressionPackage.DEFER:
				sequence_Defer(context, (Defer) semanticObject); 
				return; 
			case KernelExpressionPackage.DISCRETIZATION:
				sequence_Discretization(context, (Discretization) semanticObject); 
				return; 
			case KernelExpressionPackage.INF:
				sequence_Inf(context, (Inf) semanticObject); 
				return; 
			case KernelExpressionPackage.INTERSECTION:
				sequence_Intersection(context, (Intersection) semanticObject); 
				return; 
			case KernelExpressionPackage.NON_STRICT_SAMPLING:
				sequence_NonStrictSampling(context, (NonStrictSampling) semanticObject); 
				return; 
			case KernelExpressionPackage.STRICT_SAMPLING:
				sequence_StrictSampling(context, (StrictSampling) semanticObject); 
				return; 
			case KernelExpressionPackage.SUP:
				sequence_Sup(context, (Sup) semanticObject); 
				return; 
			case KernelExpressionPackage.UNION:
				sequence_Union(context, (Union) semanticObject); 
				return; 
			case KernelExpressionPackage.UP_TO:
				sequence_UpTo(context, (UpTo) semanticObject); 
				return; 
			case KernelExpressionPackage.WAIT:
				sequence_Wait(context, (Wait) semanticObject); 
				return; 
			}
		else if (epackage == KernelRelationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KernelRelationPackage.COINCIDENCE:
				sequence_Coincidence(context, (Coincidence) semanticObject); 
				return; 
			case KernelRelationPackage.EXCLUSION:
				sequence_Exclusion(context, (Exclusion) semanticObject); 
				return; 
			case KernelRelationPackage.NON_STRICT_PRECEDENCE:
				sequence_NonStrictPrecedence(context, (NonStrictPrecedence) semanticObject); 
				return; 
			case KernelRelationPackage.PRECEDENCE:
				sequence_Precedence(context, (Precedence) semanticObject); 
				return; 
			case KernelRelationPackage.SUB_CLOCK:
				sequence_SubClock(context, (SubClock) semanticObject); 
				return; 
			}
		else if (epackage == TimeModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TimeModelPackage.CLOCK:
				sequence_Clock(context, (Clock) semanticObject); 
				return; 
			case TimeModelPackage.IMPORT_STATEMENT:
				sequence_ImportStatement(context, (ImportStatement) semanticObject); 
				return; 
			}
		else if (epackage == EditionExtensionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EditionExtensionPackage.INT_INF_EQUAL:
				sequence_IntInfEqual(context, (IntInfEqual) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SELF_DIVIDE_ASSIGNEMENT:
				sequence_IntSelfDivAssign(context, (IntSelfDivideAssignement) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SELF_MINUS_ASSIGNEMENT:
				sequence_IntSelfMinusAssign(context, (IntSelfMinusAssignement) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SELF_MULTIPLY_ASSIGNEMENT:
				sequence_IntSelfMultAssign(context, (IntSelfMultiplyAssignement) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SELF_PLUS_ASSIGNEMENT:
				sequence_IntSelfPlusAssign(context, (IntSelfPlusAssignement) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SUP_EQUAL:
				sequence_IntSupEqual(context, (IntSupEqual) semanticObject); 
				return; 
			case EditionExtensionPackage.INTEGER_ASSIGNEMENT_BLOCK:
				sequence_IntegerAssignementBlock(context, (IntegerAssignementBlock) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     And returns And
	 *     BooleanExpression returns And
	 *     ClassicalExpression0 returns And
	 *
	 * Constraint:
	 *     ((name=String0 type=[Type|EString]?)? leftValue=BooleanExpression rightValue=BooleanExpression)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BooleanRef returns BooleanRef
	 *     BooleanExpression returns BooleanRef
	 *     ClassicalExpression0 returns BooleanRef
	 *
	 * Constraint:
	 *     (referencedBool=[BooleanElement|EString] | referencedBool=[BooleanElement|EString] | (name=ID referencedBool=[BooleanElement|EString]))
	 * </pre>
	 */
	protected void sequence_BooleanRef(ISerializationContext context, BooleanRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeclarationBlock returns DeclarationBlock
	 *
	 * Constraint:
	 *     (concreteEntities+=ConcreteEntity* classicalExpressions+=BooleanExpression*)
	 * </pre>
	 */
	protected void sequence_DeclarationBlock(ISerializationContext context, DeclarationBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Guard returns Guard
	 *
	 * Constraint:
	 *     value=BooleanExpression
	 * </pre>
	 */
	protected void sequence_Guard(ISerializationContext context, Guard semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FSMModelPackage.Literals.GUARD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FSMModelPackage.Literals.GUARD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGuardAccess().getValueBooleanExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryIntegerExpression returns IntDivide
	 *     IntegerExpression returns IntDivide
	 *     IntDivide returns IntDivide
	 *     ClassicalExpression0 returns IntDivide
	 *
	 * Constraint:
	 *     (
	 *         (name=String0? leftValue=IntegerExpression rightValue=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString])? leftValue=IntegerExpression rightValue=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_IntDivide(ISerializationContext context, IntDivide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntEqual returns IntEqual
	 *     BooleanExpression returns IntEqual
	 *     ClassicalExpression0 returns IntEqual
	 *
	 * Constraint:
	 *     (
	 *         (name=String0? leftValue=IntegerExpression rightValue=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString])? leftValue=IntegerExpression rightValue=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_IntEqual(ISerializationContext context, IntEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BooleanExpression returns IntInfEqual
	 *     IntInfEqual returns IntInfEqual
	 *     ClassicalExpression0 returns IntInfEqual
	 *
	 * Constraint:
	 *     (
	 *         (name=String0? leftValue=IntegerExpression rightValue=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString])? leftValue=IntegerExpression rightValue=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_IntInfEqual(ISerializationContext context, IntInfEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntInf returns IntInf
	 *     BooleanExpression returns IntInf
	 *     ClassicalExpression0 returns IntInf
	 *
	 * Constraint:
	 *     (
	 *         (name=String0? leftValue=IntegerExpression rightValue=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString])? leftValue=IntegerExpression rightValue=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_IntInf(ISerializationContext context, IntInf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryIntegerExpression returns IntMinus
	 *     IntegerExpression returns IntMinus
	 *     IntMinus returns IntMinus
	 *     ClassicalExpression0 returns IntMinus
	 *
	 * Constraint:
	 *     (
	 *         (name=String0? leftValue=IntegerExpression rightValue=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString])? leftValue=IntegerExpression rightValue=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_IntMinus(ISerializationContext context, IntMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryIntegerExpression returns IntMultiply
	 *     IntegerExpression returns IntMultiply
	 *     IntMultiply returns IntMultiply
	 *     ClassicalExpression0 returns IntMultiply
	 *
	 * Constraint:
	 *     (
	 *         (name=String0? leftValue=IntegerExpression rightValue=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString])? leftValue=IntegerExpression rightValue=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_IntMultiply(ISerializationContext context, IntMultiply semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryIntegerExpression returns IntPlus
	 *     IntegerExpression returns IntPlus
	 *     IntPlus returns IntPlus
	 *     ClassicalExpression0 returns IntPlus
	 *
	 * Constraint:
	 *     (
	 *         (name=String0? leftValue=IntegerExpression rightValue=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString])? leftValue=IntegerExpression rightValue=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_IntPlus(ISerializationContext context, IntPlus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryIntegerExpression returns IntSelfDivideAssignement
	 *     IntSelfDivAssign returns IntSelfDivideAssignement
	 *     IntegerExpression returns IntSelfDivideAssignement
	 *     ClassicalExpression0 returns IntSelfDivideAssignement
	 *
	 * Constraint:
	 *     (name=EString? leftValue=IntegerRef rightValue=IntegerExpression)
	 * </pre>
	 */
	protected void sequence_IntSelfDivAssign(ISerializationContext context, IntSelfDivideAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryIntegerExpression returns IntSelfMinusAssignement
	 *     IntSelfMinusAssign returns IntSelfMinusAssignement
	 *     IntegerExpression returns IntSelfMinusAssignement
	 *     ClassicalExpression0 returns IntSelfMinusAssignement
	 *
	 * Constraint:
	 *     (name=EString? leftValue=IntegerRef rightValue=IntegerExpression)
	 * </pre>
	 */
	protected void sequence_IntSelfMinusAssign(ISerializationContext context, IntSelfMinusAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryIntegerExpression returns IntSelfMultiplyAssignement
	 *     IntSelfMultAssign returns IntSelfMultiplyAssignement
	 *     IntegerExpression returns IntSelfMultiplyAssignement
	 *     ClassicalExpression0 returns IntSelfMultiplyAssignement
	 *
	 * Constraint:
	 *     (name=EString? leftValue=IntegerRef rightValue=IntegerExpression)
	 * </pre>
	 */
	protected void sequence_IntSelfMultAssign(ISerializationContext context, IntSelfMultiplyAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BinaryIntegerExpression returns IntSelfPlusAssignement
	 *     IntSelfPlusAssign returns IntSelfPlusAssignement
	 *     IntegerExpression returns IntSelfPlusAssignement
	 *     ClassicalExpression0 returns IntSelfPlusAssignement
	 *
	 * Constraint:
	 *     (name=EString? leftValue=IntegerRef rightValue=IntegerExpression)
	 * </pre>
	 */
	protected void sequence_IntSelfPlusAssign(ISerializationContext context, IntSelfPlusAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BooleanExpression returns IntSupEqual
	 *     IntSupEqual returns IntSupEqual
	 *     ClassicalExpression0 returns IntSupEqual
	 *
	 * Constraint:
	 *     (
	 *         (name=String0? leftValue=IntegerExpression rightValue=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString])? leftValue=IntegerExpression rightValue=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_IntSupEqual(ISerializationContext context, IntSupEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntSup returns IntSup
	 *     BooleanExpression returns IntSup
	 *     ClassicalExpression0 returns IntSup
	 *
	 * Constraint:
	 *     (
	 *         (name=String0? leftValue=IntegerExpression rightValue=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString])? leftValue=IntegerExpression rightValue=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_IntSup(ISerializationContext context, IntSup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns IntegerAssignementBlock
	 *     IntegerAssignementBlock returns IntegerAssignementBlock
	 *
	 * Constraint:
	 *     (name=EString actions+=IntegerAssignement actions+=IntegerAssignement*)
	 * </pre>
	 */
	protected void sequence_IntegerAssignementBlock(ISerializationContext context, IntegerAssignementBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns IntegerAssignement
	 *     BinaryIntegerExpression returns IntegerAssignement
	 *     IntegerAssignement returns IntegerAssignement
	 *     IntegerExpression returns IntegerAssignement
	 *     ClassicalExpression0 returns IntegerAssignement
	 *
	 * Constraint:
	 *     (name=EString? leftValue=IntegerRef rightValue=IntegerExpression)
	 * </pre>
	 */
	protected void sequence_IntegerAssignement(ISerializationContext context, IntegerAssignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegerExpression returns IntegerRef
	 *     IntegerRef returns IntegerRef
	 *     ClassicalExpression0 returns IntegerRef
	 *
	 * Constraint:
	 *     (integerElem=[IntegerElement|EString] | integerElem=[IntegerElement|EString] | (name=ID integerElem=[IntegerElement|EString]))
	 * </pre>
	 */
	protected void sequence_IntegerRef(ISerializationContext context, IntegerRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegerExpression returns IntegerVariableRef
	 *     IntegerVariableRef returns IntegerVariableRef
	 *     ClassicalExpression0 returns IntegerVariableRef
	 *     PrimitiveElement returns IntegerVariableRef
	 *
	 * Constraint:
	 *     (referencedVar=[AbstractEntity|EString] | referencedVar=[AbstractEntity|EString] | (name=ID? referencedVar=[AbstractEntity|EString]))
	 * </pre>
	 */
	protected void sequence_IntegerVariableRef(ISerializationContext context, IntegerVariableRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Not returns Not
	 *     BooleanExpression returns Not
	 *     ClassicalExpression0 returns Not
	 *
	 * Constraint:
	 *     (operand=BooleanExpression | ((name=String0 type=[Type|EString]?)? operand=BooleanExpression))
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Or returns Or
	 *     BooleanExpression returns Or
	 *     ClassicalExpression0 returns Or
	 *
	 * Constraint:
	 *     ((name=String0 type=[Type|EString]?)? leftValue=BooleanExpression rightValue=BooleanExpression)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SeqDecr returns SeqDecr
	 *     ClassicalExpression0 returns SeqDecr
	 *     SeqExpression returns SeqDecr
	 *
	 * Constraint:
	 *     (name=ID? operand=SeqExpression)
	 * </pre>
	 */
	protected void sequence_SeqDecr(ISerializationContext context, SeqDecr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegerExpression returns SeqGetHead
	 *     SeqGetHead returns SeqGetHead
	 *     ClassicalExpression0 returns SeqGetHead
	 *
	 * Constraint:
	 *     ((name=String0 type=[Type|EString]?)? operand=SeqExpression)
	 * </pre>
	 */
	protected void sequence_SeqGetHead(ISerializationContext context, SeqGetHead semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SeqGetTail returns SeqGetTail
	 *     ClassicalExpression0 returns SeqGetTail
	 *     SeqExpression returns SeqGetTail
	 *
	 * Constraint:
	 *     ((name=String0 type=[Type|EString]?)? operand=SeqExpression)
	 * </pre>
	 */
	protected void sequence_SeqGetTail(ISerializationContext context, SeqGetTail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SeqIsEmpty returns SeqIsEmpty
	 *     BooleanExpression returns SeqIsEmpty
	 *     ClassicalExpression0 returns SeqIsEmpty
	 *
	 * Constraint:
	 *     ((name=String0 type=[Type|EString]?)? operand=SeqExpression)
	 * </pre>
	 */
	protected void sequence_SeqIsEmpty(ISerializationContext context, SeqIsEmpty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SeqSched returns SeqSched
	 *     ClassicalExpression0 returns SeqSched
	 *     SeqExpression returns SeqSched
	 *
	 * Constraint:
	 *     (name=ID? operand=SeqExpression integerExpr=IntegerExpression)
	 * </pre>
	 */
	protected void sequence_SeqSched(ISerializationContext context, SeqSched semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateMachineDefinition returns StateMachineDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         declarationBlock=DeclarationBlock? 
	 *         initialStates+=[State|EString] 
	 *         initialStates+=[State|EString]* 
	 *         (finalStates+=[State|EString] finalStates+=[State|EString]*)? 
	 *         (states+=State | transitions+=Transition)+
	 *     )
	 * </pre>
	 */
	protected void sequence_StateMachineDefinition(ISerializationContext context, StateMachineDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (inputTransitions+=[Transition|ID] inputTransitions+=[Transition|ID]*)? 
	 *         (outputTransitions+=[Transition|ID] outputTransitions+=[Transition|ID]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (
	 *         source=[State|EString] 
	 *         target=[State|EString] 
	 *         name=EString? 
	 *         trigger=Trigger? 
	 *         guard=Guard? 
	 *         actions+=Action*
	 *     )
	 * </pre>
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     (
	 *         (trueTriggers+=[BindableEntity|EString] trueTriggers+=[BindableEntity|EString]*)? 
	 *         (falseTriggers+=[BindableEntity|EString] falseTriggers+=[BindableEntity|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegerExpression returns UnaryIntMinus
	 *     UnaryIntegerExpression returns UnaryIntMinus
	 *     UnaryIntMinus returns UnaryIntMinus
	 *     ClassicalExpression0 returns UnaryIntMinus
	 *
	 * Constraint:
	 *     (
	 *         (value=[IntegerElement|EString] operand=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString]?)? value=[IntegerElement|EString] operand=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_UnaryIntMinus(ISerializationContext context, UnaryIntMinus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegerExpression returns UnaryIntPlus
	 *     UnaryIntegerExpression returns UnaryIntPlus
	 *     UnaryIntPlus returns UnaryIntPlus
	 *     ClassicalExpression0 returns UnaryIntPlus
	 *
	 * Constraint:
	 *     (
	 *         (value=[IntegerElement|EString] operand=IntegerExpression) | 
	 *         ((name=String0 type=[Type|EString]?)? value=[IntegerElement|EString] operand=IntegerExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_UnaryIntPlus(ISerializationContext context, UnaryIntPlus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Xor returns Xor
	 *     BooleanExpression returns Xor
	 *     ClassicalExpression0 returns Xor
	 *
	 * Constraint:
	 *     ((name=String0 type=[Type|EString]?)? leftValue=BooleanExpression rightValue=BooleanExpression)
	 * </pre>
	 */
	protected void sequence_Xor(ISerializationContext context, Xor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
