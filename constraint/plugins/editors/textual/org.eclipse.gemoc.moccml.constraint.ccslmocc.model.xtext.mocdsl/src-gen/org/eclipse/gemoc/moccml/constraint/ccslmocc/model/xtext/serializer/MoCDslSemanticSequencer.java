/*
 * generated by Xtext 2.31.0
 */
package org.eclipse.gemoc.moccml.constraint.ccslmocc.model.xtext.serializer;

import com.google.inject.Inject;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.BasicTypePackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.BooleanElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Box;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Char;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.DenseClockType;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.DiscreteClockType;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.EnumerationType;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Field;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.IntegerElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Real;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.RealElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Record;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.RecordElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.SequenceElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.SequenceType;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.StringElement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.And;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.BooleanRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.BooleanVariableRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.ClassicalExpressionPackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntDivide;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntEqual;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntInf;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntMinus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntMultiply;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntPlus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntSup;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntegerRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.IntegerVariableRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.Not;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.NumberSeqRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.NumberSeqVariableRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.Or;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealEqual;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealInf;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealMinus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealMultiply;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealPlus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealSup;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.RealVariableRef;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqDecr;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqGetHead;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqGetTail;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqIsEmpty;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.SeqSched;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.UnaryIntMinus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.UnaryIntPlus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.UnaryRealMinus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.UnaryRealPlus;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClassicalExpression.Xor;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.AbstractEntity;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.Binding;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ClockExpressionAndRelationPackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ConditionalExpressionDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ConditionalRelationDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExprCase;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.Expression;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExpressionDeclaration;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExpressionLibrary;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExternalExpressionDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.ExternalRelationDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Concatenation;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Death;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Defer;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Discretization;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Inf;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Intersection;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.KernelExpressionPackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.NonStrictSampling;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.StrictSampling;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Sup;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Union;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.UpTo;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelExpression.Wait;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.Coincidence;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.Exclusion;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.KernelRelationPackage;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.NonStrictPrecedence;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.Precedence;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.KernelRelation.SubClock;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.Library;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.RelCase;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.Relation;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.RelationDeclaration;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.RelationLibrary;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.UserExpressionDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.CCSLModel.ClockExpressionAndRelation.UserRelationDefinition;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.Clock;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.ImportStatement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.TimeModelPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.gemoc.moccml.constraint.ccslmoc.model.moccml.moccml.CcslmoccPackage;
import org.eclipse.gemoc.moccml.constraint.ccslmoc.model.moccml.moccml.FinishClock;
import org.eclipse.gemoc.moccml.constraint.ccslmoc.model.moccml.moccml.StartClock;
import org.eclipse.gemoc.moccml.constraint.ccslmoc.model.moccml.moccml.StateMachineRelationDefinition;
import org.eclipse.gemoc.moccml.constraint.ccslmoc.model.moccml.moccml.StateRelationBasedLibrary;
import org.eclipse.gemoc.moccml.constraint.ccslmocc.model.xtext.services.MoCDslGrammarAccess;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.DeclarationBlock;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.FSMModelPackage;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.Guard;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.IntegerAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.State;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.StateMachineDefinition;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.Transition;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.Trigger;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.EditionExtensionPackage;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntInfEqual;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSelfDivideAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSelfMinusAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSelfMultiplyAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSelfPlusAssignement;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntSupEqual;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.FSMModel.editionextension.IntegerAssignementBlock;
import org.eclipse.gemoc.moccml.constraint.fsmkernel.model.xtext.serializer.FSMDslSemanticSequencer;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MoCDslSemanticSequencer extends FSMDslSemanticSequencer {

	@Inject
	private MoCDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BasicTypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BasicTypePackage.BOOLEAN:
				sequence_Boolean(context, (fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Boolean) semanticObject); 
				return; 
			case BasicTypePackage.BOOLEAN_ELEMENT:
				sequence_BooleanElement(context, (BooleanElement) semanticObject); 
				return; 
			case BasicTypePackage.BOX:
				sequence_Box(context, (Box) semanticObject); 
				return; 
			case BasicTypePackage.CHAR:
				sequence_Char(context, (Char) semanticObject); 
				return; 
			case BasicTypePackage.DENSE_CLOCK_TYPE:
				sequence_DenseClockType(context, (DenseClockType) semanticObject); 
				return; 
			case BasicTypePackage.DISCRETE_CLOCK_TYPE:
				sequence_DiscreteClockType_Impl(context, (DiscreteClockType) semanticObject); 
				return; 
			case BasicTypePackage.ENUMERATION_TYPE:
				sequence_EnumerationType(context, (EnumerationType) semanticObject); 
				return; 
			case BasicTypePackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case BasicTypePackage.INTEGER:
				sequence_Integer(context, (fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.Integer) semanticObject); 
				return; 
			case BasicTypePackage.INTEGER_ELEMENT:
				sequence_IntegerElement(context, (IntegerElement) semanticObject); 
				return; 
			case BasicTypePackage.REAL:
				sequence_Real(context, (Real) semanticObject); 
				return; 
			case BasicTypePackage.REAL_ELEMENT:
				sequence_RealElement(context, (RealElement) semanticObject); 
				return; 
			case BasicTypePackage.RECORD:
				sequence_Record(context, (Record) semanticObject); 
				return; 
			case BasicTypePackage.RECORD_ELEMENT:
				sequence_RecordElement(context, (RecordElement) semanticObject); 
				return; 
			case BasicTypePackage.SEQUENCE_ELEMENT:
				sequence_SequenceElement(context, (SequenceElement) semanticObject); 
				return; 
			case BasicTypePackage.SEQUENCE_TYPE:
				sequence_SequenceType(context, (SequenceType) semanticObject); 
				return; 
			case BasicTypePackage.STRING:
				sequence_String1(context, (fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.BasicType.String) semanticObject); 
				return; 
			case BasicTypePackage.STRING_ELEMENT:
				sequence_StringElement(context, (StringElement) semanticObject); 
				return; 
			}
		else if (epackage == ClassicalExpressionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ClassicalExpressionPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case ClassicalExpressionPackage.BOOLEAN_REF:
				sequence_BooleanRef(context, (BooleanRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.BOOLEAN_VARIABLE_REF:
				sequence_BooleanVariableRef(context, (BooleanVariableRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_DIVIDE:
				sequence_IntDivide(context, (IntDivide) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_EQUAL:
				sequence_IntEqual(context, (IntEqual) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_INF:
				sequence_IntInf(context, (IntInf) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_MINUS:
				sequence_IntMinus(context, (IntMinus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_MULTIPLY:
				sequence_IntMultiply(context, (IntMultiply) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_PLUS:
				sequence_IntPlus(context, (IntPlus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INT_SUP:
				sequence_IntSup(context, (IntSup) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INTEGER_REF:
				sequence_IntegerRef(context, (IntegerRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.INTEGER_VARIABLE_REF:
				sequence_IntegerVariableRef(context, (IntegerVariableRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case ClassicalExpressionPackage.NUMBER_SEQ_REF:
				sequence_NumberSeqRef(context, (NumberSeqRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.NUMBER_SEQ_VARIABLE_REF:
				sequence_NumberSeqVariableRef(context, (NumberSeqVariableRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_EQUAL:
				sequence_RealEqual(context, (RealEqual) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_INF:
				sequence_RealInf(context, (RealInf) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_MINUS:
				sequence_RealMinus(context, (RealMinus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_MULTIPLY:
				sequence_RealMultiply(context, (RealMultiply) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_PLUS:
				sequence_RealPlus(context, (RealPlus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_REF:
				sequence_RealRef(context, (RealRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_SUP:
				sequence_RealSup(context, (RealSup) semanticObject); 
				return; 
			case ClassicalExpressionPackage.REAL_VARIABLE_REF:
				sequence_RealVariableRef(context, (RealVariableRef) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_DECR:
				sequence_SeqDecr(context, (SeqDecr) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_GET_HEAD:
				sequence_SeqGetHead(context, (SeqGetHead) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_GET_TAIL:
				sequence_SeqGetTail(context, (SeqGetTail) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_IS_EMPTY:
				sequence_SeqIsEmpty(context, (SeqIsEmpty) semanticObject); 
				return; 
			case ClassicalExpressionPackage.SEQ_SCHED:
				sequence_SeqSched(context, (SeqSched) semanticObject); 
				return; 
			case ClassicalExpressionPackage.UNARY_INT_MINUS:
				sequence_UnaryIntMinus(context, (UnaryIntMinus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.UNARY_INT_PLUS:
				sequence_UnaryIntPlus(context, (UnaryIntPlus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.UNARY_REAL_MINUS:
				sequence_UnaryRealMinus(context, (UnaryRealMinus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.UNARY_REAL_PLUS:
				sequence_UnaryRealPlus(context, (UnaryRealPlus) semanticObject); 
				return; 
			case ClassicalExpressionPackage.XOR:
				sequence_Xor(context, (Xor) semanticObject); 
				return; 
			}
		else if (epackage == ClockExpressionAndRelationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ClockExpressionAndRelationPackage.ABSTRACT_ENTITY:
				sequence_AbstractEntity(context, (AbstractEntity) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.CONDITIONAL_EXPRESSION_DEFINITION:
				sequence_ConditionalExpressionDefinition(context, (ConditionalExpressionDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.CONDITIONAL_RELATION_DEFINITION:
				sequence_ConditionalRelationDefinition(context, (ConditionalRelationDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXPR_CASE:
				sequence_ExprCase(context, (ExprCase) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXPRESSION_DECLARATION:
				sequence_ExpressionDeclaration(context, (ExpressionDeclaration) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXPRESSION_LIBRARY:
				sequence_ExpressionLibrary(context, (ExpressionLibrary) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXTERNAL_EXPRESSION_DEFINITION:
				sequence_ExternalExpressionDefinition(context, (ExternalExpressionDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.EXTERNAL_RELATION_DEFINITION:
				sequence_ExternalRelationDefinition(context, (ExternalRelationDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.REL_CASE:
				sequence_RelCase(context, (RelCase) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.RELATION_DECLARATION:
				sequence_RelationDeclaration(context, (RelationDeclaration) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.RELATION_LIBRARY:
				sequence_RelationLibrary(context, (RelationLibrary) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.USER_EXPRESSION_DEFINITION:
				sequence_UserExpressionDefinition_Impl(context, (UserExpressionDefinition) semanticObject); 
				return; 
			case ClockExpressionAndRelationPackage.USER_RELATION_DEFINITION:
				sequence_UserRelationDefinition_Impl(context, (UserRelationDefinition) semanticObject); 
				return; 
			}
		else if (epackage == FSMModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FSMModelPackage.DECLARATION_BLOCK:
				sequence_DeclarationBlock(context, (DeclarationBlock) semanticObject); 
				return; 
			case FSMModelPackage.GUARD:
				sequence_Guard(context, (Guard) semanticObject); 
				return; 
			case FSMModelPackage.INTEGER_ASSIGNEMENT:
				sequence_IntegerAssignement(context, (IntegerAssignement) semanticObject); 
				return; 
			case FSMModelPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case FSMModelPackage.STATE_MACHINE_DEFINITION:
				sequence_StateMachineDefinition(context, (StateMachineDefinition) semanticObject); 
				return; 
			case FSMModelPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case FSMModelPackage.TRIGGER:
				sequence_Trigger(context, (Trigger) semanticObject); 
				return; 
			}
		else if (epackage == KernelExpressionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KernelExpressionPackage.CONCATENATION:
				sequence_Concatenation(context, (Concatenation) semanticObject); 
				return; 
			case KernelExpressionPackage.DEATH:
				sequence_Death(context, (Death) semanticObject); 
				return; 
			case KernelExpressionPackage.DEFER:
				sequence_Defer(context, (Defer) semanticObject); 
				return; 
			case KernelExpressionPackage.DISCRETIZATION:
				sequence_Discretization(context, (Discretization) semanticObject); 
				return; 
			case KernelExpressionPackage.INF:
				sequence_Inf(context, (Inf) semanticObject); 
				return; 
			case KernelExpressionPackage.INTERSECTION:
				sequence_Intersection(context, (Intersection) semanticObject); 
				return; 
			case KernelExpressionPackage.NON_STRICT_SAMPLING:
				sequence_NonStrictSampling(context, (NonStrictSampling) semanticObject); 
				return; 
			case KernelExpressionPackage.STRICT_SAMPLING:
				sequence_StrictSampling(context, (StrictSampling) semanticObject); 
				return; 
			case KernelExpressionPackage.SUP:
				sequence_Sup(context, (Sup) semanticObject); 
				return; 
			case KernelExpressionPackage.UNION:
				sequence_Union(context, (Union) semanticObject); 
				return; 
			case KernelExpressionPackage.UP_TO:
				sequence_UpTo(context, (UpTo) semanticObject); 
				return; 
			case KernelExpressionPackage.WAIT:
				sequence_Wait(context, (Wait) semanticObject); 
				return; 
			}
		else if (epackage == KernelRelationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KernelRelationPackage.COINCIDENCE:
				sequence_Coincidence(context, (Coincidence) semanticObject); 
				return; 
			case KernelRelationPackage.EXCLUSION:
				sequence_Exclusion(context, (Exclusion) semanticObject); 
				return; 
			case KernelRelationPackage.NON_STRICT_PRECEDENCE:
				sequence_NonStrictPrecedence(context, (NonStrictPrecedence) semanticObject); 
				return; 
			case KernelRelationPackage.PRECEDENCE:
				sequence_Precedence(context, (Precedence) semanticObject); 
				return; 
			case KernelRelationPackage.SUB_CLOCK:
				sequence_SubClock(context, (SubClock) semanticObject); 
				return; 
			}
		else if (epackage == TimeModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TimeModelPackage.CLOCK:
				sequence_Clock(context, (Clock) semanticObject); 
				return; 
			case TimeModelPackage.IMPORT_STATEMENT:
				sequence_ImportStatement(context, (ImportStatement) semanticObject); 
				return; 
			}
		else if (epackage == EditionExtensionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EditionExtensionPackage.INT_INF_EQUAL:
				sequence_IntInfEqual(context, (IntInfEqual) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SELF_DIVIDE_ASSIGNEMENT:
				sequence_IntSelfDivAssign(context, (IntSelfDivideAssignement) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SELF_MINUS_ASSIGNEMENT:
				sequence_IntSelfMinusAssign(context, (IntSelfMinusAssignement) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SELF_MULTIPLY_ASSIGNEMENT:
				sequence_IntSelfMultAssign(context, (IntSelfMultiplyAssignement) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SELF_PLUS_ASSIGNEMENT:
				sequence_IntSelfPlusAssign(context, (IntSelfPlusAssignement) semanticObject); 
				return; 
			case EditionExtensionPackage.INT_SUP_EQUAL:
				sequence_IntSupEqual(context, (IntSupEqual) semanticObject); 
				return; 
			case EditionExtensionPackage.INTEGER_ASSIGNEMENT_BLOCK:
				sequence_IntegerAssignementBlock(context, (IntegerAssignementBlock) semanticObject); 
				return; 
			}
		else if (epackage == CcslmoccPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CcslmoccPackage.FINISH_CLOCK:
				sequence_FinishClock(context, (FinishClock) semanticObject); 
				return; 
			case CcslmoccPackage.START_CLOCK:
				sequence_StartClock(context, (StartClock) semanticObject); 
				return; 
			case CcslmoccPackage.STATE_MACHINE_RELATION_DEFINITION:
				sequence_CCSLStateMachineRelationDefinition(context, (StateMachineRelationDefinition) semanticObject); 
				return; 
			case CcslmoccPackage.STATE_RELATION_BASED_LIBRARY:
				sequence_StateRelationBasedLibrary(context, (StateRelationBasedLibrary) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelationDefinition returns StateMachineRelationDefinition
	 *     CCSLStateMachineRelationDefinition returns StateMachineRelationDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         declaration=[RelationDeclaration|EString] 
	 *         declarationBlock=DeclarationBlock? 
	 *         initialStates+=[State|EString] 
	 *         initialStates+=[State|EString]* 
	 *         (finalStates+=[State|EString] finalStates+=[State|EString]*)? 
	 *         (states+=State | transitions+=Transition)+
	 *     )
	 * </pre>
	 */
	protected void sequence_CCSLStateMachineRelationDefinition(ISerializationContext context, StateMachineRelationDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns FinishClock
	 *     FinishClock returns FinishClock
	 *
	 * Constraint:
	 *     clock=[BindableEntity|EString]
	 * </pre>
	 */
	protected void sequence_FinishClock(ISerializationContext context, FinishClock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CcslmoccPackage.Literals.FINISH_CLOCK__CLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CcslmoccPackage.Literals.FINISH_CLOCK__CLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFinishClockAccess().getClockBindableEntityEStringParserRuleCall_3_0_1(), semanticObject.eGet(CcslmoccPackage.Literals.FINISH_CLOCK__CLOCK, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImportStatement returns ImportStatement
	 *
	 * Constraint:
	 *     (importURI=STRING alias=String0)
	 * </pre>
	 */
	protected void sequence_ImportStatement(ISerializationContext context, ImportStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TimeModelPackage.Literals.IMPORT_STATEMENT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimeModelPackage.Literals.IMPORT_STATEMENT__IMPORT_URI));
			if (transientValues.isValueTransient(semanticObject, TimeModelPackage.Literals.IMPORT_STATEMENT__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TimeModelPackage.Literals.IMPORT_STATEMENT__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportStatementAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.accept(grammarAccess.getImportStatementAccess().getAliasString0ParserRuleCall_3_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns StartClock
	 *     StartClock returns StartClock
	 *
	 * Constraint:
	 *     clock=[BindableEntity|EString]
	 * </pre>
	 */
	protected void sequence_StartClock(ISerializationContext context, StartClock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CcslmoccPackage.Literals.START_CLOCK__CLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CcslmoccPackage.Literals.START_CLOCK__CLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartClockAccess().getClockBindableEntityEStringParserRuleCall_3_0_1(), semanticObject.eGet(CcslmoccPackage.Literals.START_CLOCK__CLOCK, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateRelationBasedLibrary returns StateRelationBasedLibrary
	 *
	 * Constraint:
	 *     (name=EString imports+=ImportStatement* (expressionLibraries+=ExpressionLibrary | relationLibraries+=RelationLibrary | predefinedTypes+=Type)*)
	 * </pre>
	 */
	protected void sequence_StateRelationBasedLibrary(ISerializationContext context, StateRelationBasedLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (source=[State|ID] target=[State|ID] name=EString? ((trigger=Trigger guard=Guard?) | (guard=Guard trigger=Trigger?))? actions+=Action*)
	 * </pre>
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     (
	 *         (trueTriggers+=[BindableEntity|EString] trueTriggers+=[BindableEntity|EString]*) | 
	 *         (falseTriggers+=[BindableEntity|EString] falseTriggers+=[BindableEntity|EString]*)
	 *     )
	 * </pre>
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
